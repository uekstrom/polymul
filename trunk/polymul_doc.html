<html lang="en">
<head>
<title>Polymul polynomial multiplication library</title>
</head>
<body>
<div style="width:50em">
<h1>Polymul 1.0</h1>
<p>
Polymul is a self-contained C++ template library for efficient
multiplication of multivariate polynomials.  It is intended for low
order polynomials of a few variables, but is in principle limited only
by the compilers maximal template recursion depth. Polynomials can be
created over any scalar type, such as integers or floating point numbers.
</p>

<h2>About</h2>
The Polymul library was written by Ulf Ekstr&ouml;m 2009. It is
released under the MIT license (see <tt>polymul.h</tt> for the
exact license text). The library is not yet finalized, so
some API changes can happen. If you use this library in a 
scientific work you are kindly asked to cite 
<i>``Polymul library, Ulf Ekstr&ouml;m 2009''</i>.

<h2>Download</h2>
The latest version of the library can be downloaded from 
<a href="http://polymul.googlecode.com/">polymul.googlecode.com</a>.


<h2>Polynomial representation</h2> 
<p>The library deals with homogeneous multivariate polynomials, stored
order by order with terms sorted lexicographically. For example, a
second order polynomial in two variables (<tt>x,y</tt>) has its
coefficients stored in the order <tt>1 x y x^2 xy y^2</tt>. As a
result of this ordering the lowest order terms of a polynomial is
simply the first part of the coefficients array. On the other hand
there is no simple way to pick out all terms containing a certain
subset of the variables. 
</p>
<p>
A <tt>Ndeg</tt> degree polynomial of <tt>Nvar</tt> variables has
<tt>binomial(Nvar+Ndeg,Ndeg)</tt> coefficients, giving
a <tt>O(Ndeg<sup>Nvar</sup>)</tt> scaling. Multiplication then
formally requires <tt>O(Ndeg<sup>2 Nvar</sup>)</tt>
multiplications. However, for small polynomials the exact details of
the implementation is more important than the formal scaling, and
this is where C++ templates provide an efficient solution.
</p>
<p>
Because the library uses polynomial order and number of variables
as template parameters these have to be known at compile time.
This makes the library most useful for cases where either the 
order or the number of variables in known beforehand, and the
other parameter can be handled through a switch. The C++ standard
recommends a maximum recursion depth of at least 17, so 
in principle you are limited to polynomials of degree less than
17 and with less than 17 variables. 
</p>


<h2>C++ API</h2>
<h3><tt>template&lt;class numtype, int Nvar, int Ndeg&gt; class
polynomial;</tt></h3> 
<p>Class that encapsulates
<tt>binomial(Nvar+Ndeg,Ndeg)</tt> coefficients. It is safe to cast (with <tt>reinterpret_cast</tt>) an array
of <tt>numtype</tt> to a <tt>polynomial</tt>, or vice versa. It is also safe to cast a polynomial to a polynomial type of lower degree, but with the same number of variables.
The <tt>polynomial</tt> class supports access to the coefficients
through the <tt>[]</tt> indexing operator, where the index is the order of the term described above.
 <tt>Nvar</tt> must be greater or equal to one, while <tt>Ndeg</tt> must be a non-negative number</p>
<p>
  The scalar type <tt>numtype</tt> can be any type that supports the <tt>+</tt> and <tt>*</tt> operators,
  and which has a commuting product.
</p>
<p>
The <tt>polynomial</tt> class has the following methods:
<h3><tt>polynomial::polynomial();</tt><h3>
<h3><tt>polynomial::polynomial(const numtype &c0);</tt></h3>
Constructors for <tt>polynomial</tt>. If the <tt>c0</tt> argument is given the
polynomial is set to zero except the constant term which is set
to <tt>c0</tt>.

<h3><tt>void polynomial::zero();</tt></h3>
Set all coefficients to 0.

<h3><tt>static int polynomial::size();</tt></h3> Return the number of
coefficients (terms). This is a compile-time constant.

<h3><tt>numtype polynomial::eval(const numtype x[Nvar]);</tt></h3>
Evaluate the polynomial at x. This is reasonable fast but may
not be optimal in terms of number of multiplications and additions.

<h3><tt>void polynomial::exponents(int term, int
exponents[Nvar]);</tt></h3> Calculate the exponents of <tt>term</tt>, using
a very slow method. This is intended for printing, not for fast
computation.
<h3><tt>int polynomial::term_index(int exponents[Nvar]);</tt></h3>
Return the index of the term with <tt>exponents</tt>. Again, this
is a slow function intended for printing and debugging.

<h3>Multiplication functions</h3>

A few different functions are provided for multiplying
polynomials. These functions are not methods
of <tt>polynomial</tt>. Template arguments have been omitted below,
check <tt>polymul.h</tt> for details. You can use these functions
directly on coefficient arrays by using an
appropriate <tt>reinterpret_cast</tt>.

<h3><tt>void polymul(polynomial &dst, const polynomial &p1, const
    polynomial &p2);</tt></h3> Multiply two polynomials with the same
    number of variables, <tt>p1</tt> and <tt>p2</tt>, and put the
    result in <tt>dst</tt> (a polynomial of the right degree to fit
    the product exactly). Note that the degree of <tt>p1</tt>
    and <tt>p2</tt> does not have to be the same, but <tt>dst</tt>
    must have the exact right order to be able to represent the
    product.

<h3><tt>void taylormul(polynomial &dst, const polynomial &p1, const
    polynomial &p2);</tt></h3> Here <tt>dst, p1</tt> and <tt>p2</tt>
    are polynomials of the same degree.  The product of <tt>p1</tt>
    and <tt>p2</tt> is put in <tt>dst</tt>, but only those terms up
    to the original order of the polynomials (the higher terms are not
    calculated). The name comes from the usefulness of this function
    in calculating the product of Taylor expansions. 

<h3><tt>void taylormul(polynomial &p1, const polynomial
    &p2);</tt></h3> Like <tt>taylormul()</tt>, but computes <tt>p1 = p1*p2</tt> in-place.


<h2>Performance</h2> In a micro-benchmark one million 5 variable, 5:th
degree double precision polynomials were multiplied
with <tt>taylormul()</tt> in four seconds on a core2 2.4GHz
cpu. These polynomials have 252 coefficients each, so about 480MB/s of
coefficients was produced. 

<h2>Contact</h2>
The author can be reached at uekstrom (AT) gmail.com. Bug reports, comments, or suggestions for improvements are greatly appreciated.

<hr>
<small>Ulf Ekstr&ouml;m, June 2009</small>
</div>
</body>
</html>
